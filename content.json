{"meta":{"title":"kai_wei的资源基地","subtitle":"一个什么都有的资源大杂烩（当然，还在施工）","description":"记录生活，记录自己","author":"kai_wei凯惟","url":"https://kai-wei-kfuse.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-04-07T03:47:39.000Z","updated":"2020-04-07T03:48:28.000Z","comments":true,"path":"categories/index.html","permalink":"https://kai-wei-kfuse.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-04-07T05:57:01.000Z","updated":"2020-04-07T05:57:02.000Z","comments":true,"path":"about/index-1.html","permalink":"https://kai-wei-kfuse.github.io/about/index-1.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-07T03:52:16.000Z","updated":"2020-04-11T03:30:06.000Z","comments":false,"path":"about/index.html","permalink":"https://kai-wei-kfuse.github.io/about/index.html","excerpt":"","text":"本站有大量的资源和教程提供，目前正在开发….游戏攻略、博客搭建教程、软件资源、魔方教程等等都有，目前更新不稳定，佛系更新。QQ：1171113925欢迎骚扰 ♪(･ω･)ﾉ"},{"title":"标签","date":"2020-04-07T03:51:10.000Z","updated":"2020-04-07T03:51:48.000Z","comments":true,"path":"tags/index.html","permalink":"https://kai-wei-kfuse.github.io/tags/index.html","excerpt":"","text":""},{"title":"“tags","date":"2020-04-07T04:12:59.000Z","updated":"2020-04-07T04:13:00.000Z","comments":true,"path":"“tags/index.html","permalink":"https://kai-wei-kfuse.github.io/%E2%80%9Ctags/index.html","excerpt":"","text":""},{"title":"泰拉瑞亚mod","date":"2020-04-11T02:31:00.000Z","updated":"2020-04-11T02:31:02.000Z","comments":true,"path":"泰拉瑞亚mod/index.html","permalink":"https://kai-wei-kfuse.github.io/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9Amod/index.html","excerpt":"","text":""}],"posts":[{"title":"实验5","slug":"实验5","date":"2022-01-18T05:21:04.000Z","updated":"2022-01-18T08:46:50.025Z","comments":true,"path":"2022/01/18/实验5/","link":"","permalink":"https://kai-wei-kfuse.github.io/2022/01/18/%E5%AE%9E%E9%AA%8C5/","excerpt":"","text":"实验5链表操作：题目：编写一个链表综合程序,实现以下功能: 编写一个链表的构建函数输入任意多条的长度不等的字符串，结束的条件是直接回车，用动态链表方式处理保存各个字符串, 编写一个显示函数, 调用即显示前面所有输入过的字符串， 编写一个查询函数用以查询前面输入的字符串里是否有某字符串。 编写一个文件保存函数, 调用后链表上的所有字符串保存在文件data.txt里. 编写一个读文件添加链表数据的函数, 调用后,能把文件data.txt里的字符添加到当前的链表上 构建功能选择菜单, 通过菜单选择运行以上哪个函数的功能. （广东工业大学计算机） 第一部分：创建链表与打印首先我立马打了几个框架，第一次测试：失败 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct strings&#123; char s[100]; strings* next; &#125;;strings* head=NULL;//设置头指针，指向NULL;strings *create(int n)//创建链表&#123; strings *head=NULL,*node=NULL,*end=NULL; head=(strings*)malloc(sizeof(strings)); end=head;//初始链表只有一个头指针，所以尾等于头 while(gets(node-&gt;s)&amp;&amp;strcmp(node-&gt;s,\"\")!=0) //for(int i=0;i&lt;n;i++) &#123; node=(strings*)malloc(sizeof(strings));//每一次开辟一个空间 scanf(\"%s\",node-&gt;s); //node-&gt;s=a; end-&gt;next=node; end=node; &#125; end-&gt;next=NULL; return head;&#125;void print(strings* p)//打印&#123; //strings *p=head; int i=1; p = p-&gt;next; while(p!=NULL) &#123; printf(\"%d %s\",i,p-&gt;s); p=p-&gt;next; i++; &#125;&#125;int main()&#123; int n; scanf(\"%d\",n); head=create(n); print(head);&#125; 运行结果1： 无输出 思考：1、经过测试打印和创建都有问题修改：1、更换表达方式 1while(gets(node-&gt;s)&amp;&amp;strcmp(node-&gt;s,\"\")!=0) 改成 1while(gets(node-&gt;s)&amp;&amp;strlen(node-&gt;s)!=0) 2、更改打印的代码 12345678910void print(strings* p)//打印&#123; int i=1; while(p!=NULL) &#123; printf(\"%d %s\",i,p-&gt;s); p=p-&gt;next; i++; &#125;&#125; 删掉了一行p = p-&gt;next;这样才能输出第一个节点3、参考运行成功代码发现原来看的别人的博客写的代码是错的，根本运行不了（流汗）。第二次测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct strings&#123; char s[100]; strings* next; &#125;;strings* head=NULL;//设置头指针，指向NULL;strings * create()//创建链表&#123; int n=0; strings *head=NULL,*node=NULL,*end=NULL; node=(strings*)malloc(sizeof(strings)); end=node;//初始链表只有一个头指针，所以尾等于头 while(gets(node-&gt;s)&amp;&amp;strlen(node-&gt;s)!=0) &#123; n++; if(n==1)head=node; else end-&gt;next=node; end=node; node=(strings*)malloc(sizeof(strings)); &#125; end-&gt;next=NULL; return (head);&#125;struct strings *creat()&#123; struct strings *head,*p1,*p2; int n=0; head=NULL; p1=( struct strings *) malloc(sizeof(struct strings)); p2=p1; gets(p1-&gt;s); while(strlen(p1-&gt;s)!=0) &#123; n=n+1; if (n==1) head=p1; else p2-&gt;next=p1; p2=p1; p1=(struct strings *)malloc(sizeof(struct strings)); gets(p1-&gt;s); &#125; p2-&gt;next=NULL; return(head);&#125;void print(strings* p)//打印&#123; int i=1; while(p!=NULL) &#123; printf(\"%d %s \",i,p-&gt;s); p=p-&gt;next; i++; &#125;&#125;int main()&#123; head=create(); print(head);&#125; 运行成功。打印和创建函数完成。 第二部分：文件读写和添加节点添加节点放在这里是因为在添加节点的同时顺便写入文件。1、读取文件 123456FILE *fp=fopen(data,\"r\");//data是文件名if(fp==NULL) &#123; printf(\"Error\\n\");//如果读取失败输出失败 return; &#125; 和创建链表相同，每次打开文件都要重新读取重新创建链表；不同的是，输入不一样，变成了从文件读取，使用fscanf()函数，完整函数如下 解释：fscanf()：从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取 12345678910111213141516171819202122232425struct strings *readfile(char *data)//读取文件并且创建链表&#123; FILE *fp=fopen(data,\"r\"); if(fp==NULL) &#123; printf(\"Error\\n\"); return NULL; &#125;//和上面一样 struct strings *head,*node,*end; node=(struct strings*)malloc(sizeof(struct strings)); end=node; int n=0; while(fscanf(fp,\"%s\",node-&gt;s)!=EOF)//和前面不同的是这里，从文件读取 &#123; n++; if(n==1) head=node; else end-&gt;next=node; end=node; node=(struct strings*)malloc(sizeof(struct strings)); &#125; end-&gt;next=NULL; return head;&#125; 2、保存到文件这里要了解几个函数（菜鸟教程）①fputc()函数函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。②fputs()函数函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。③fprintf()函数int fprintf(FILE *fp,const char *format, …) 函数把一个字符串写入到文件中。 12345678910111213141516void save(struct strings *p,char *data)//保存到文件&#123; FILE *fp=fopen(data,\"w\"); if (fp==NULL) &#123; printf(\"Error\\n\"); return; &#125; //----一模一样的如果读取失败输出失败----- while(p!=NULL) &#123; fprintf(fp,\"%s\\n\",p-&gt;s); p=p-&gt;next; &#125; fclose(fp);&#125; 3、添加节点添加手动输入的字符 1234567891011121314151617struct strings *addtofile(struct strings *head)//添加节点&#123; struct strings *ne; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings));//先开辟空间 gets(ne-&gt;s);//输入手动输入的字符 if (strlen(ne-&gt;s)!=0) &#123; head=addtolist(head,ne);//添加节点函数在下面 &#125; else&#123; free(ne);//如果没了就释放掉 break; &#125; &#125; return head;&#125; 123456789101112131415struct strings *addtolist(struct strings *head,struct strings* news)//添加节点&#123; struct strings* p=head; if (head==NULL)&#123;//似乎一定要写这个if，不然就无输出 head=news; news-&gt;next=NULL; return head; &#125; while (p-&gt;next!=NULL)&#123; p=p-&gt;next; &#125; p-&gt;next=news; news-&gt;next=NULL; return head;&#125; 4、程序主体这是实现文件读写的链表程序，read file读取文件并且输出，在add：后面输入字符，如果回车两次，即没有输入，则会打印整个链表程序如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct strings&#123; char s[100]; struct strings* next; &#125;;struct strings* head=NULL;//设置头指针，指向NULL;struct strings * create()//创建链表&#123; int n=0; struct strings *head=NULL,*node=NULL,*end=NULL; node=(struct strings*)malloc(sizeof(struct strings)); end=node;//初始链表只有一个头指针，所以尾等于头 while(gets(node-&gt;s)&amp;&amp;strlen(node-&gt;s)!=0) &#123; n++; if(n==1)head=node; else end-&gt;next=node; end=node; node=(struct strings*)malloc(sizeof(struct strings)); &#125; end-&gt;next=NULL; return (head);&#125;void print(struct strings* p)//打印&#123; int i=1; while(p!=NULL) &#123; printf(\"%s\\n\",p-&gt;s); p=p-&gt;next; i++; &#125;&#125;void save(struct strings *p,char *filename)//保存到文件&#123; FILE *fp=fopen(filename,\"w\"); if (fp==NULL) &#123; printf(\"Error\\n\"); return; &#125; while(p!=NULL) &#123; fprintf(fp,\"%s\\n\",p-&gt;s); p=p-&gt;next; &#125; fclose(fp);&#125;struct strings *readfile(char *data)//读取文件并且创建链表&#123; FILE *fp=fopen(data,\"r\"); if(fp==NULL) &#123; printf(\"Error\\n\"); return NULL; &#125; struct strings *head,*node,*end; node=(struct strings*)malloc(sizeof(struct strings)); end=node; int n=0; while(fscanf(fp,\"%s\",node-&gt;s)!=EOF)//和前面不同的是这里 &#123; n++; if(n==1) head=node; else end-&gt;next=node; end=node; node=(struct strings*)malloc(sizeof(struct strings)); &#125; end-&gt;next=NULL; return head;&#125;struct strings *addtolist(struct strings *head,struct strings* news)//添加节点&#123; struct strings* p=head; if (head==NULL)&#123; head=news; news-&gt;next=NULL; return head; &#125; while (p-&gt;next!=NULL)&#123; p=p-&gt;next; &#125; p-&gt;next=news; news-&gt;next=NULL; return head;&#125;struct strings *addtofile(struct strings *head)//添加节点&#123; struct strings *ne; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings)); gets(ne-&gt;s); if (strlen(ne-&gt;s)!=0) &#123; head=addtolist(head,ne); &#125; else&#123; free(ne); break; &#125; &#125; return head;&#125;int main()&#123; printf(\"read file:\\n\"); head=readfile(\"data.txt\");//读取文件并创建链表 print(head);//打印 printf(\"add:\\n\"); addtofile(head);//添加字符串到链表 printf(\"display:\\n\"); print(head); save(head,\"data.txt\");//保存 //head=create();&#125; 第三部分：菜单实现一、两个键盘读取函数：1、检测输入按键函数getch()函数返回按键的数值； UP = 72 DOWN = 80 LEFT = 75 RIGHT = 77 ENTER = 13 ESC = 27 //按键数值 2、函数kbhit() 检查当前是否有键盘输入，若有则返回一个非0值，否则返回0 。函数名：kbhit()（VC++6.0下为_kbhit()）用法：int kbhit(void);包含头文件： include &lt;conio.h&gt;两者区别：kbhit() 在执行时,检测是否有按键按下,有按下返回非0值，一般是1；没有按下返回0；是非阻塞函数。getch() 在执行时，检测按下什么键，如果不按键该函数不返回，是阻塞函数 二、设置文本样式我们需要制作一个菜单，使用方向键选择选项，并且高亮显示，这里就需要设置字体格式，使用SetConsoleTextAttribute()函数可以设置文字颜色和高亮。 1SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),0x70);//高亮显示 1SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),0x07);//正常显示 这里是简短的测试程序 12345678910111213141516171819202122232425262728#include&lt;stdlib.h&gt;//测试读取键盘和设置高亮#include&lt;conio.h&gt;#include&lt;windows.h&gt;#include&lt;stdio.h&gt;int main()&#123; while(true)&#123; if(kbhit())&#123; char c=getch(); if(GetAsyncKeyState(VK_UP)) printf(\"up,\"); if(GetAsyncKeyState(VK_DOWN)) printf(\"Down,\"); //读取到上或者下就对应输出 if(GetAsyncKeyState(VK_LEFT))&#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),0x70); printf(\"\\nHighlight,\"); &#125; if(GetAsyncKeyState(VK_RIGHT))&#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),0x07); printf(\"\\nNormal,\"); //读取到左或者右就高亮或恢复（如果高亮则恢复，正常则不变） &#125; Sleep(100); &#125; &#125; return 0;&#125; 程序结果三、显示菜单并且高亮读取键盘完成了，就需要显示出菜单界面，我们设置一个char数组来储存。 123456789char MenuText[7][30]=&#123; \"[A] Create a List \", \"[B] Display the List \", \"[C] Find the Word \", \"[D] Save to File \", \"[E] Read to List \", \"[F] Add to List \", \"[Q] Exit \"&#125;; 将他打印出来的话，就是正常的样子。但是我们需要让他高亮，这里就需要思考，如何让特定的选项高亮呢？这里我们在打印菜单函数coutmenu（）函数里面设置了一个变量highlight，他的值是多少代表是第几行需要高亮。接着我们使用for循环7次（有7行）一次输出，这样菜单里面就有一个选项是高亮的。 1234567891011121314151617void coutmenu(int highlight)//打印菜单函数&#123; int i; printf(\"\\n======================\\n\");//只是输出边界线 for (i=0;i&lt;7;i++)&#123; if (i==highlight-1) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0x70); //设置高亮 else SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0x07); //设置正常 printf(\"%s\\n\",MenuText[i]);//设置完成后输出 &#125; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7); printf(\"======================\\n\"); &#125; 如图所示（假设这里highlight=2，那么第二行就会高亮）不知道大家有没有想到，怎么让他按照我们的意愿高亮。想不到也没关系，我也想不到，这里我们通过反复清空屏幕，再反复输出的方式，来实现上下移动。 四、实现选项移动因为我们要反复输出我们就需要清空屏幕，这里我们用system(&quot;cls&quot;);来清空屏幕。同时我们需要使用sleep()函数来让程序暂停，如果数值设置太短，我们按方向键的时候，可能已经经过了好多个循环，相当于你按了n多次方向键，会跳的很快。 123456789101112131415for(;;)&#123; if (kbhit())&#123; c=getch(); if (GetAsyncKeyState(VK_UP))&#123; high=(high&gt;1)?high-1:7;//程序的巧妙之处，超过7则回退到1 Sleep(140); system(\"cls\"); coutmenu(high);//打印菜单函数 &#125; if (GetAsyncKeyState(VK_DOWN))&#123; high=(high&lt;7)?high+1:1; Sleep(140); system(\"cls\"); coutmenu(high); &#125;&#125;&#125; （这里是另一个函数，所以高亮显示的行号用high表示）这个程序的巧妙之处在于每次收到上下的信号就会对变量high做出运算，DOWN的情况是大于7则变成1，小于7则加1。这样在第七行（最后一行），再按一次down就会回到第一行。不过这个回退不是必要的，也可以不加。五、按回车执行对应程序在前面的if语句后面接上 if 语句，判断是否回车，回车符是&#39;\\r&#39;，接着用swich语句来判断情况执行语句。 12345678910111213141516171819202122else if(c=='\\r')&#123;//判断回车 system(\"cls\");//清空屏幕 coutmenu(high);//再打印 printf(\"command is [%c]\",'A'+high-1);//同时输出在执行的选项（测试用，后面可以删） switch (high) &#123; case 1:printf(\"1\");//后面需要加上代码 break; case 2:printf(\"2\"); break; case 3:printf(\"3\"); break; case 4:printf(\"4\"); break; case 5:printf(\"5\"); break; case 6:printf(\"6\"); break; case 7:printf(\"7\"); break; &#125; &#125; 效果如图，按回车后才回显示 第四部分：加上查找功能没有太大难度，基础的查找操作 12345678910111213141516171819void find(struct strings *head)//查找&#123; char* word; gets(word); struct strings *p=head; int i=1; //p=p-&gt;next; while(p!=NULL) &#123; if(strcmp(p-&gt;s,word)==0) &#123; printf(\"Search successfully\\n\"); return ; &#125; p=p-&gt;next; &#125; printf(\"Search unsuccessfully!\\n\"); return ;&#125; 第五部分：把菜单整合到链表程序中所有工作都分工做完了，现在就剩下整合合微调了。一、判断语句设置这是整合后的Switch函数，这里的函数一定要调用对，别搞错了，所以函数命名的时候一定要清楚。 123456789101112131415161718192021222324252627282930313233switch (high) &#123; system(\"cls\"); coutmenu(high); case 1: printf(\"add:\\n\");//创建链表，并且手动输入 head=create(); break; case 2: print(head);//打印 break; case 3: printf(\"Input your word which you want to find:\");//查找 find(head); break; case 4: save(head,\"data.txt\");//保存到文件（会清空原本） break; case 5: //head=readfile(\"data.txt\"); head=addinlist(head,\"data.txt\");//(读取文件的内容添加到链表后面） break; case 6: printf(\"add:\");//手动输入添加字符串到链表后面 addtofile(head); break; case 7: return 0;//退出 break; &#125; //对应处理的程序段 printf(\"command %c finished\",'A'+high-1); &#125; 二、修改一个函数这里前面一个函数需要修改才能使用，因为实现的功能是读取文件内容，把内容添加到链表后面，不是手动输入，所以前面的addtofile函数需要修改。 修改前： 1234567891011121314151617struct strings *addtofile(struct strings *head)//添加节点&#123; struct strings *ne; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings)); gets(ne-&gt;s); if (strlen(ne-&gt;s)!=0) &#123; head=addtolist(head,ne); &#125; else&#123; free(ne); break; &#125; &#125; return head;&#125; 先把文件读写的代码加上去FILE *fp=fopen(data,&quot;r&quot;);同样加上是否读取文件成功的判断，gets改成fscanf(fp,&quot;%s&quot;,ne-&gt;s)。修改后： 12345678910111213141516171819202122struct strings *addinlist(struct strings *head,char* data)&#123; struct strings *ne; FILE *fp=fopen(data,\"r\"); if(fp==NULL) &#123; printf(\"Error\\n\"); return NULL; &#125; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings)); if (fscanf(fp,\"%s\",ne-&gt;s)!=EOF) &#123; head=addtolist(head,ne); &#125; else&#123; free(ne); break; &#125; &#125; return head;&#125; 最后就完成了。 附加：按字母键跳转选项菜单前面有ABCDEF,其实还可以通过按字母跳转，原理相同，关键在于求出高亮的是第几行。 12345678if (c&lt;='z'&amp;&amp; c&gt;='a')c=c-('a'-'A'); if (c&lt;='F' &amp;&amp; c&gt;='A')&#123; //对应处理的程序段 high=c-'A'+1; system(\"cls\"); coutmenu(high); printf(\"command [%c] \",c); &#125; 完整代码（运行平台vscode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;struct strings&#123; char s[100]; struct strings* next; &#125;;char MenuText[7][40]=&#123; \"|[A] Create a List |\", \"|[B] Display the List |\", \"|[C] Find the Word |\", \"|[D] Save to File |\", \"|[E] Read to List |\", \"|[F] Add to List |\", \"|[Q] Exit |\"&#125;;void coutmenu(int highlight)&#123; int i; printf(\"\\n---------------------------\\n\"); for (i=0;i&lt;7;i++)&#123; if (i==highlight-1) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0x70); else SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0x07); printf(\"%s\\n\",MenuText[i]); &#125; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7); printf(\"---------------------------\\n\"); &#125;struct strings* head=NULL;//设置头指针，指向NULL;struct strings * create()//创建链表&#123; int n=0; struct strings *head=NULL,*node=NULL,*end=NULL; node=(struct strings*)malloc(sizeof(struct strings)); end=node;//初始链表只有一个头指针，所以尾等于头 while(gets(node-&gt;s)&amp;&amp;strlen(node-&gt;s)!=0) &#123; n++; if(n==1)head=node; else end-&gt;next=node; end=node; node=(struct strings*)malloc(sizeof(struct strings)); &#125; end-&gt;next=NULL; return (head);&#125;void print(struct strings* p)//打印&#123; int i=1; while(p!=NULL) &#123; printf(\"%s\\n\",p-&gt;s); p=p-&gt;next; i++; &#125;&#125;void find(struct strings *head)//查找&#123; char* word; gets(word); struct strings *p=head; int i=1; //p=p-&gt;next; while(p!=NULL) &#123; if(strcmp(p-&gt;s,word)==0) &#123; printf(\"Search successfully\\n\"); return ; &#125; p=p-&gt;next; &#125; printf(\"Search unsuccessfully!\\n\"); return ;&#125;void save(struct strings *p,char *filename)//保存到文件&#123; FILE *fp=fopen(filename,\"w\"); if (fp==NULL) &#123; printf(\"Error\\n\"); return; &#125; while(p!=NULL) &#123; fprintf(fp,\"%s\\n\",p-&gt;s); p=p-&gt;next; &#125; fclose(fp);&#125;struct strings *readfile(char *data)//读取文件并且创建链表&#123; FILE *fp=fopen(data,\"r\"); if(fp==NULL) &#123; printf(\"Error\\n\"); return NULL; &#125; struct strings *head,*node,*end; node=(struct strings*)malloc(sizeof(struct strings)); end=node; int n=0; while(fscanf(fp,\"%s\",node-&gt;s)!=EOF)//和前面不同的是这里 &#123; n++; if(n==1) head=node; else end-&gt;next=node; end=node; node=(struct strings*)malloc(sizeof(struct strings)); &#125; end-&gt;next=NULL; return head;&#125;struct strings *addtolist(struct strings *head,struct strings* news)//添加节点&#123; struct strings* p=head; if (head==NULL)&#123; head=news; news-&gt;next=NULL; return head; &#125; while (p-&gt;next!=NULL)&#123; p=p-&gt;next; &#125; p-&gt;next=news; news-&gt;next=NULL; return head;&#125;struct strings *addtofile(struct strings *head)//添加节点&#123; struct strings *ne; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings)); gets(ne-&gt;s); if (strlen(ne-&gt;s)!=0) &#123; head=addtolist(head,ne); &#125; else&#123; free(ne); break; &#125; &#125; return head;&#125;struct strings *addinlist(struct strings *head,char* data)&#123; struct strings *ne; FILE *fp=fopen(data,\"r\"); if(fp==NULL) &#123; printf(\"Error\\n\"); return NULL; &#125; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings)); if (fscanf(fp,\"%s\",ne-&gt;s)!=EOF) &#123; head=addtolist(head,ne); &#125; else&#123; free(ne); break; &#125; &#125; return head;&#125;int main()&#123; char c; int high=1; coutmenu(high); for(;;)&#123; if (kbhit())&#123; c=getch(); if (GetAsyncKeyState(VK_UP))&#123; high=(high&gt;1)?high-1:7; Sleep(140); system(\"cls\"); coutmenu(high); &#125; if (GetAsyncKeyState(VK_DOWN))&#123; high=(high&lt;7)?high+1:1; Sleep(140); system(\"cls\"); coutmenu(high); &#125; if (c&lt;='z'&amp;&amp; c&gt;='a')c=c-('a'-'A'); if (c&lt;='F' &amp;&amp; c&gt;='A')&#123; //对应处理的程序段 high=c-'A'+1; system(\"cls\"); coutmenu(high); printf(\"command [%c] \",c); &#125; else if (c=='\\r')&#123; switch (high) &#123; system(\"cls\"); coutmenu(high); case 1: printf(\"Add strings:\\n\"); head=create(); break; case 2: print(head); break; case 3: printf(\"Input your word which you want to find:\"); find(head); break; case 4: save(head,\"data.txt\"); break; case 5: //head=readfile(\"data.txt\"); head=addinlist(head,\"data.txt\"); break; case 6: printf(\"Add strings:\"); addtofile(head); break; case 7: return 0; break; &#125; //对应处理的程序段 printf(\"command %c finished\",'A'+high-1); &#125; else if (c=='Q') return 0; /*printf(\"read file:\\n\"); head=readfile(\"data.txt\");//读取文件并创建链表 print(head);//打印 printf(\"add:\\n\"); addtofile(head); printf(\"display:\\n\"); print(head); save(head,\"data.txt\"); */ //head=create(); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"你好，访客","slug":"hello-world","date":"2022-01-18T04:42:09.776Z","updated":"2020-04-11T03:57:40.000Z","comments":true,"path":"2022/01/18/hello-world/","link":"","permalink":"https://kai-wei-kfuse.github.io/2022/01/18/hello-world/","excerpt":"","text":"创建这个博客算是跟风的吧，不过我确实想有一个平台可以自己有个性化的形式写教程写文章什么什么的，所以就花了好大力气创建了这个博客。 索引博客有什么内容？目前的计划： 1234hexo+github个人博客创建及美化泰拉瑞亚全流程攻略魔方教程与魔方测评我家的猫 其他平台哔哩哔哩: kai_wei凯惟 交流QQ:1171113925欢迎骚扰O(∩_∩)O 打赏（未完工）马上就来","categories":[{"name":"索引","slug":"索引","permalink":"https://kai-wei-kfuse.github.io/categories/%E7%B4%A2%E5%BC%95/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"edge浏览器简单设置","slug":"edge","date":"2020-05-02T02:34:19.000Z","updated":"2020-05-03T03:01:46.000Z","comments":true,"path":"2020/05/02/edge/","link":"","permalink":"https://kai-wei-kfuse.github.io/2020/05/02/edge/","excerpt":"","text":"edge出了问题？edge的简单设置帮你解决 Edge是微软出品的浏览器，这里不多做介绍。 主要讲讲在edge设置菜单的各种功能，使用过程中出现的问题，怎么通过设置解决。 问题一：刚打开浏览器是别的网页而不是新标签页 别的网页（比如什么上网导航什么的） 新标签页（上图就是新标签页） 这时候就有两种可能： 1、被网页劫持了，这时可能电脑中了病毒，杀毒可以解决（把浏览器设置改了之后不行的话才是） 2、浏览器设置被改了（可能是被别的软件改的，因为一般人不会去点那个） 点右上角的策略号，找到设置打开 然后找到启动时，选择新标签页，再关掉浏览器重开。 问题二：搜索的时候没办法在搜索框输入，而只能在顶部输入下图：搜索框，这个问题困扰了我很久，只要在搜索框输入任何东西，都会自动弹到地址栏那里，而且这种情况是突然出现的，我也没改设置。 解决方法，同样是打开设置 点击隐私与服务，往下拉，找到服务最下面的地址栏 如果这里显示的是地址栏，那么就改成搜索框，问题就解决了 问题三：新标签页如何隐藏下面的广告/新闻（如何美化新标签页） 新标签页右上角有个设置，点击如何选择自定义，看自己喜好选择内容显示还是不显示，内容就是指那些新闻和广告什么的。 这里就是edge的简单设置，这是其中一部分，以后会写更多的。","categories":[],"tags":[{"name":"软件应用","slug":"软件应用","permalink":"https://kai-wei-kfuse.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"}]},{"title":"win10怎么激活？win10一键激活","slug":"win10激活","date":"2020-04-30T02:34:19.000Z","updated":"2020-04-30T08:22:06.000Z","comments":true,"path":"2020/04/30/win10激活/","link":"","permalink":"https://kai-wei-kfuse.github.io/2020/04/30/win10%E6%BF%80%E6%B4%BB/","excerpt":"","text":"win10怎么激活？win10一键激活我们辛辛苦苦把windows装好了以后，那么就可以正常使用windows了。 还不知道怎么装win10？点这里 https://kai-wei-kfuse.github.io/2020/04/13/win10/#more 下一步就是激活windows首先说说不激活windows和激活有什么区别答案：没什么区别，只是右下角会有一个激活windows水印，不影响正常使用。 激活并不难，只要一个激活工具，一键就可以激活。这里推荐小马激活工具 度盘：https://pan.baidu.com/s/1hYF7mYaR42gt5Fe-omMgHQ 提取码：buhb","categories":[],"tags":[{"name":"系统相关","slug":"系统相关","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"}]},{"title":"win10 U盘装机法","slug":"win10","date":"2020-04-13T02:34:19.000Z","updated":"2020-04-15T03:56:36.000Z","comments":true,"path":"2020/04/13/win10/","link":"","permalink":"https://kai-wei-kfuse.github.io/2020/04/13/win10/","excerpt":"","text":"#装机教程# Windows 10 U盘装机windows 10目前越来越普及，目前（2020年）win 10用户已经超过了win7，如下图（这张图是一年前的，很旧了，现在肯定不止这个数据）而且微软官方已经停止了对win 7的支持。 所以，windows 10 大势所趋，还不赶紧装个win10玩玩？问题来了：怎么装个win10？不急，下面告诉你 1.什么是U盘装机？适用于什么情况？U盘装机就是用一个 在U盘里的小系统 （即win PE系统）把你要装的系统安装在主机上 的方法，他是个万能的方法，没有什么限制，如果你的电脑是一台新的电脑（里面没有系统），那么就可以用这个方法，只要有个U盘就行。如果是win7升级win10也可以用这个方法。注意的是，你的C盘（系统盘）需要格式化，这里提醒一下，格式化后面再说。 想知道你适用于哪种装机方法的可以看这里-&gt;（链接） 2.准备工作这里要准备一个硬件和一个工具和一个系统镜像。 ① 一个空U盘，大小4G以上（win PE大概占2G）如果没有空U盘也可以把U盘内文件备份一次（就复制出来） 装PE会格式化U盘！！！ ② 下载winPE可以百度搜win pe 或者 点这里http://www.wepe.com.cn/在官网下 ③ 下载win10镜像（镜像就是一个用来安装系统文件）在MSDN下载https://msdn.itellyou.cn/如图，操作系统&gt;win10&gt;选择版本&gt;详细信息&gt;复制链接 在迅雷下载即可 注意！x64：64位系统 x86：32位系统 business：商业版（也就是专业版） consumer：消费者版（也就是普通版） 3.第一步：安装winPE进U盘里什么是winPE？win PE就是专门用来装系统的系统，也就是预装系统的系统，它是一种系统预装环境和工具。 打开安装到U盘（右下） 注意待写入U盘是不是那个空U盘 然后就点安装，等它完成。（安装的时候你会发现你不能打开U盘） 然后你会发现你的U盘容量变小了，这部分就是PE系统占了。这样你的U盘就能恢复平常正常使用了，不过我推荐还是有一个专门的装机盘会好一点（几十块一个U盘够用好多年呢）。 4.第二步：把你下载的系统镜像放入U盘方便在pe系统内找到你下的镜像，这个写着10的长的要死的就是镜像文件，图标上有个光盘的样子。 5.第三步：重启电脑，设置U盘启动重启电脑，在显示主板牌子的时候按F8（不同品牌的按键不一定一样，有的F12或者F11，一般屏幕底部会显示）进入BIOS，这里建议百度如何进入BIOS。我的BIOS是三代，如果是2代或1代（跟我不一样的建议百度”BIOS”），不用在意不同品牌的按键布局，反正功能肯定是有的，进入界面会有一个启动顺序，找到你U盘的型号移到前面就行。也可以点高级模式，在启动选项设置，1、2、3的顺序就是启动顺序。设置成功的话，点击退出，并保存设置。然后电脑会再一次启动，启动成功会出现进度条，进度条过完后会有win10图标。打开之后就是下图的样子。然后，打开你的U盘，找到你的镜像文件，右键点击装载（这里会生成一个虚拟光驱），然后下一步 6.第四步：格式化硬盘格式化掉你要装系统的那个硬盘，右键硬盘就能格式化，或者用PE里自带的分区助手备份一次再格式化也可以，注意看看硬盘是不是NTFS格式，如果不是要转到NTFS格式。 7.第五步：打开windows安装器,开始安装系统打开桌面的windows安装器如图，第一个选择你刚刚装载的虚拟光驱，然后按这个路径sources&gt;install.wim，下面两个都选你要装系统的硬盘（你刚刚格式化那个），然后选择版本（各版本区别可以自己查，这里推荐专业版）。然后就可以点开始安装了。 安装完成就拔掉U盘，重启电脑就可以了。然后就会显示win10的安装界面，接着就是选语言等等的界面，之后的这里就不多说了，按它的默认选项就好了。 然后你的win10就装好了。欢呼吧！！！","categories":[],"tags":[{"name":"系统相关","slug":"系统相关","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"}]},{"title":"泰拉瑞亚模组冲突如何解决","slug":"泰拉瑞亚","date":"2020-04-11T02:34:19.000Z","updated":"2020-04-13T02:05:20.000Z","comments":true,"path":"2020/04/11/泰拉瑞亚/","link":"","permalink":"https://kai-wei-kfuse.github.io/2020/04/11/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/","excerpt":"","text":"如何快速找出模组冲突首先你可以大概推测（这一步可做可不做），想想模组从哪里下，版本对不对，下载的可能是有问题的。 准备工作： 创建一个空的测试角色（每次排查都要用它） 把模组分类：主要模组、次要模组、功能性模组等等方便排查 确定mod冲突的类型，我大致分三类，无法加载模组（其实这个直接能看到不用排查）、无法创建世界（卡住或崩溃）、能进游戏能正常玩耍，但是出现小bug（比如我出现过的：一个召唤物只能杀一个敌人，然后召唤物就消失了、模组掉落物无法掉落） 如图，创建世界的时候卡在这里。 1.全部模组禁用全部禁用，一个不剩 2.先启用大型模组（如果有的话），比如灾厄，瑟银等等，一次启用1-4个（如果你有那么多的话）。然后用测试角色，然后就按照你发现的bug或冲突进行测试 举个栗子：无法创建世界（卡在一个位置创建不了）这时就要用测试角色创建世界（时间可能稍久，但没有办法） 3.然后就有两个分支①发现问题这时就要看启用的几个模组（范围大大缩小），一个一个禁用，顺序可以随便定，注意禁用之后还有问题的话禁用的就先别启用，直到找出问题mod。（如果bug消失，那应该是你这次测试禁用的mod有冲突，这就是问题mod）找出后启用刚刚第一次测试的几个大型mod，出现问题的mod不用开，再测试有没有出现bug。 ②没有问题这时要保持大型mod启用，在启用次要mod，跟前面一样以此类推，找到最终问题。 总的来说，据我所知找模组冲突没有特别简便的方法，只有靠自己一一排除，也没有什么软件可以一键查出，所以下模组的时候也要谨慎，每个模组都是独立开发的，互相有冲突实属正常，最后希望大家能找到好玩又没有冲突的整合包！！！","categories":[],"tags":[{"name":"泰拉瑞亚","slug":"泰拉瑞亚","permalink":"https://kai-wei-kfuse.github.io/tags/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/"}]},{"title":"泰拉瑞亚原版全流程攻略","slug":"first-text","date":"2020-04-05T13:35:55.000Z","updated":"2020-04-07T07:07:02.000Z","comments":true,"path":"2020/04/05/first-text/","link":"","permalink":"https://kai-wei-kfuse.github.io/2020/04/05/first-text/","excerpt":"","text":"废话：《泰拉瑞亚》是由Re-Logic公司开发的一款高自由度的沙盒游戏，于2011年5月16日在PC上发行。攻略开始：正在开发…正在开发..正在开发…正在开发….正在开发…","categories":[{"name":"泰拉瑞亚","slug":"泰拉瑞亚","permalink":"https://kai-wei-kfuse.github.io/categories/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/"}],"tags":[{"name":"泰拉瑞亚","slug":"泰拉瑞亚","permalink":"https://kai-wei-kfuse.github.io/tags/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/"}]}],"categories":[{"name":"索引","slug":"索引","permalink":"https://kai-wei-kfuse.github.io/categories/%E7%B4%A2%E5%BC%95/"},{"name":"泰拉瑞亚","slug":"泰拉瑞亚","permalink":"https://kai-wei-kfuse.github.io/categories/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"软件应用","slug":"软件应用","permalink":"https://kai-wei-kfuse.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"},{"name":"系统相关","slug":"系统相关","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"},{"name":"泰拉瑞亚","slug":"泰拉瑞亚","permalink":"https://kai-wei-kfuse.github.io/tags/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/"}]}