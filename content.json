{"meta":{"title":"kai_wei的资源基地","subtitle":"一个什么都有的资源大杂烩（当然，还在施工）","description":"记录生活，记录自己","author":"kai_wei凯惟","url":"https://kai-wei-kfuse.github.io","root":"/"},"pages":[{"title":"about","date":"2020-04-07T05:57:01.000Z","updated":"2020-04-07T05:57:02.000Z","comments":true,"path":"about/index-1.html","permalink":"https://kai-wei-kfuse.github.io/about/index-1.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-07T03:52:16.000Z","updated":"2020-04-11T03:30:06.000Z","comments":false,"path":"about/index.html","permalink":"https://kai-wei-kfuse.github.io/about/index.html","excerpt":"","text":"本站有大量的资源和教程提供，目前正在开发….游戏攻略、博客搭建教程、软件资源、魔方教程等等都有，目前更新不稳定，佛系更新。QQ：1171113925欢迎骚扰 ♪(･ω･)ﾉ"},{"title":"标签","date":"2020-04-07T03:51:10.000Z","updated":"2020-04-07T03:51:48.000Z","comments":true,"path":"tags/index.html","permalink":"https://kai-wei-kfuse.github.io/tags/index.html","excerpt":"","text":""},{"title":"“tags","date":"2020-04-07T04:12:59.000Z","updated":"2020-04-07T04:13:00.000Z","comments":true,"path":"“tags/index.html","permalink":"https://kai-wei-kfuse.github.io/%E2%80%9Ctags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-07T03:47:39.000Z","updated":"2020-04-07T03:48:28.000Z","comments":true,"path":"categories/index.html","permalink":"https://kai-wei-kfuse.github.io/categories/index.html","excerpt":"","text":""},{"title":"泰拉瑞亚mod","date":"2020-04-11T02:31:00.000Z","updated":"2020-04-11T02:31:02.000Z","comments":true,"path":"泰拉瑞亚mod/index.html","permalink":"https://kai-wei-kfuse.github.io/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9Amod/index.html","excerpt":"","text":""}],"posts":[{"title":"滑动窗口+单调队列 概念与例题（P1886 洛谷）","slug":"滑动窗口","date":"2022-02-23T01:51:25.000Z","updated":"2022-02-23T01:52:11.417Z","comments":true,"path":"2022/02/23/滑动窗口/","link":"","permalink":"https://kai-wei-kfuse.github.io/2022/02/23/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"（广东工业大学ACM专题学习一） 滑动窗口滑动窗口算法（也叫尺取）的概念其实很简单，很多情况下要结合更多知识来解题，比如单调队列。什么是滑动窗口：在计算机网络中，滑动窗口算法是用来改善吞吐量的技术。在算法中则是维护一个由左右指针在字符串或数组中构成的窗口（窗口大小可变或固定），在窗口中进行的操作。 单调队列也叫双端队列，简单来说就是通过不段入队和出队，保证队列元素是单调的。 专题学习一 滑动窗口下面我们主要讲一下如何维护一个单调队列。有一个长为 n 的序列 a，以及一个大小为 k 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。输入格式输入一共有两行，第一行有两个正整数 n,k。 第二行 n 个整数，表示序列 a。输出格式输出共两行，第一行为每次窗口滑动的最小值第二行为每次窗口滑动的最大值输入： 8 31 3 -1 -3 5 3 6 7 输出： -1 -3 -3 -3 3 33 3 5 5 6 7 分析：这道题是滑动窗口+单调队列的模板题。 我们知道只要每窗口移动一次，输出最值即可；那么我们怎么求每个窗口的最值呢？如果暴力的话，我们可以在窗口每移动一次就遍历整窗口寻找最值，但是每移动一次就遍历，相当于遍历窗口位置还要遍历窗口里面的元素，复杂度可想而知。 所以我们只知道滑动窗口是不足够的，这里我们还需要学习单调队列来解决。 (我们先看找最小值) 维护一个单调队列，这个队列的性质是从队头到队尾元素一定是递增的同时遍历数组，队列中的元素在数组中的下标一定是单调递增的（因为每次都从队尾进去），而队头就是最小元素。 每遍历一个元素就让他和队尾判断；如果这个元素比队尾元素大，说明如果元素入队队列依然可以保持单调；如果这个元素比队尾小，也就是说如果这个元素入队了，队列就不单调了，这里我们就要踢出队尾元素（换个说法：按照找最值的思维，如果队尾元素比加入元素还大，那么这个队尾元素就完全没有成为最小值的潜力了），同时，不要别忘记窗口大小是有限的，如果队头元素下标和队尾元素下标之差大于窗口大小，就要踢出队头元素。 接下来我们模拟一下样例。（队列以数组元素为元素，也可以下标为元素，这里不讲）注意：图中红色X就是被踢除的元素。注意：我们要等到i遍历到k（也就是窗口大小），才开始输出。如图：①遍历元素1，1入队，没有元素出队。②遍历元素3，3大于队尾1，3入队，没有元素出队。③遍历元素-1，-1小于队尾3，3出队，再次判断，-1小于新队尾1，1出队，-1入队。④遍历元素-3，-3小于队尾-1，-1出队，-3入队。⑤遍历元素5，5大于-3,5入队，没有元素出队。以此类推，遍历到3时，3小于5，5出队，再次判断，3大于-3，3入队。这个过程维护了一个单调的队列，但还不够。 我们看最后一行，如果按照上面的判断，6可以进队，但是认真看看样例，窗口大小是3，-3到6已结溢出窗口了，所以我们每次判断都要加一个窗口长度的维护。新建一个队列，每次元素进队的同时，下标也进队。这时候添加一个操作①遍历元素1，1入队，(队头和队尾下标之差小于3)没有元素出队。②遍历元素3，3大于队尾1，3入队，（队头和队尾下标之差小于3）没有元素出队。③遍历元素-1，-1小于队尾3，3出队，再次判断，-1小于新队尾1，1出队，（队头和队尾下标之差小于3）-1入队。④遍历元素-3，-3小于队尾-1，-1出队，-3入队（队头和队尾下标之差小于3）。⑤遍历元素5，5大于-3,5入队，（队头和队尾下标之差小于3）没有元素出队。以此类推，遍历到3时，3小于5，5出队，再次判断，3大于-3，3入队。遍历到6,6入队，（队头和队尾下标之差等于3）踢出队头元素-3。只要每次遍历都输出队头就能得到序列，最大值只要判断的时候换一个符号。参考代码： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;//使用数组来模拟队列using namespace std;int a[1000002];int q[1000002];int x[1000002];int q1[1000002];int x1[1000002];int head=1,tail=0;int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123;//最小 while(head&lt;=tail &amp;&amp; x[head]+k&lt;=i)head++;//head右移代表踢出队头 while(head&lt;=tail &amp;&amp; q[tail]&gt;a[i])tail--;//tail左移代表踢出队尾 q[++tail]=a[i];//队尾右移同时元素入队 x[tail]=i; if(i&gt;=k)printf(\"%d \",q[head]); &#125; cout&lt;&lt;endl; for(int i=1;i&lt;=n;i++)&#123;//最大 while(head&lt;=tail &amp;&amp; x1[head]+k&lt;=i)head++; while(head&lt;=tail &amp;&amp; q1[tail]&lt;a[i])tail--; q1[++tail]=a[i]; x1[tail]=i; if(i&gt;=k)printf(\"%d \",q1[head]); &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"洛谷P1048 [NOIP2005 普及组] 采药 （01背包）","slug":"01背包","date":"2022-02-23T01:49:57.000Z","updated":"2022-02-23T01:50:41.904Z","comments":true,"path":"2022/02/23/01背包/","link":"","permalink":"https://kai-wei-kfuse.github.io/2022/02/23/01%E8%83%8C%E5%8C%85/","excerpt":"","text":"动态规划之01背包（广东工业大学 2022 寒假集训 专题二）洛谷P1048采药题目描述辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？ 输入格式第一行有 2 个整数 T（1≤T≤1000）和 M（1≤M≤100），用一个空格隔开，T 代表总共能够用来采药的时间，M 代表山洞里的草药的数目。 接下来的 M 行每行包括两个在 1 到 100 之间（包括 1 和 100）的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出格式输出在规定的时间内可以采到的草药的最大总价值。 输入输出样例 说明/提示【数据范围】 对于 30% 的数据，M≤10；对于全部的数据，M≤100。【题目来源】 NOIP 2005 普及组第三题讲解：01背包问题的特点是选与不选，每个物品只有一个，选了就没有了。 既然是动态规划，那么我们就有dp数组，这里我们构建二维数组能方便理解01背包（没有为什么，就是二维数组），dp[i][j]表示我们选i件物品和有j背包容量时，能挣的最多的钱；我们假设有四个物品（物品重量 和 取得这个物品能挣多少钱）和10g的背包容量。表格中横向是背包容量（从0到10），纵向是选择的物品数量（0到4，用数组存物品重量m[1~4]）。那么我们就是要求dp[4][10]。1、为什么要有横轴表示背包的容量从0到10？可以看一个例子，假如我们装物品装到第四件（6g 6元），我们的选择是带走它，那么此时背包就只剩10-6=4g，如果我们求了背包容量为4时的最大值（挣的钱的最大值），我们只要两者加起来就能得到这种情况下（带走第四件物品）的结果。2、为什么要纵轴表示选取物品从0件到4件？可以按照正常人思维想，拿物品不就是一个一个拿的吗？（bushi），其实这样我们可以求得拿1件物品/拿两件物品…所挣的最大钱数。 第一行：0个物品当然挣0元第二行： 我们拿第一件物品，2g 3元，背包容量为0时，放不下，因此我们不选；为1时，也放不下，但是2~10都能放得下，所以后面我们选，都能挣钱，（dp[1][10]代表拿一件物品时10背包容量所挣的最多的钱，确实是3）第三行： 我们拿第二件物品，3g4元，同样，0 1 2个背包容量装不下，因此我们不选，那么就和前一行一样，相当于我们选第1个物品，而不选第二个。当容量为3时我们1有两种选择，选和不选，1、如果选，那么此时背包用了3个容量只剩下0的容量，我们已经选了这个物品，所以我们要在前一行找，也就是dp[2][3]=dp[1][0]=0，dp[1][0]+m[2]=0+4=4，2、如果不选，那么就是选一个物品，是前一行的dp[1][3]=3，很明显4大于3，我们选4。以此类推…把剩下的解决后得到表格，答案就是dp[4][10]=10总结：这里的转移方程为dp[ i ] [ j ]=max(dp[ i-1 ] [ j ],dp[ i -1] [ j - m [ i ] ]+val[i])二维数组只是方便理解，我我们发现dp[ i ] [ j ]只会和前一行有关，所以我们可以用一维滚动数组来实现。dp[j]=max(dp[j],dp[j-m[i]]+val[i]);在b站找嘉特的动态规划视频有详细解释，我就是在那学的，这里懒得再打了。模板参考ac代码： 12345678910111213141516171819#include&lt;iostream&gt;//动态规划模板#include&lt;algorithm&gt;using namespace std;int t,num,c[102],v[102],dp[1002]=&#123;0&#125;;int main()&#123; cin&gt;&gt;t&gt;&gt;num; for(int i=1;i&lt;=num;i++)&#123; scanf(\"%d %d\",&amp;c[i],&amp;v[i]); &#125; for(int i=1;i&lt;=num;i++)&#123;//外循环是枚举物品编号 for(int j=t;j&gt;=c[i];j--)&#123;//内循环是枚举背包容量 dp[j]=max(dp[j],dp[j-c[i]]+v[i]); &#125; for(int j=1;j&lt;=t;j++)&#123; &#125; &#125; cout&lt;&lt;dp[t];&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"最长上升子序列LIS","slug":"最长上升子序列","date":"2022-02-23T01:48:16.000Z","updated":"2022-02-23T01:49:28.909Z","comments":true,"path":"2022/02/23/最长上升子序列/","link":"","permalink":"https://kai-wei-kfuse.github.io/2022/02/23/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"[NOIP1999 普及组] 导弹拦截题目描述某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度（雷达给出的高度数据是\\le 50000≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式1行，若干个整数（个数≤100000） NOIP 原题数据规模不超过 2000。 输出格式2行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出样例这里我们需要二分查找优化找子序列的过程，不过这道题变成了最长不上升子序列。这个时候我们设dp[i]的意义为：长度为i的子序列中末尾的最大值，i相当于子序列的长度。可以想象一下，这个序列的最后一位如果数字越大，那么构成更长的不上升子序列的长度期望会更长。比如：6 4 2 1和6 4 3 2 两个序列，末尾越大越有可能会构成更长的子序列。 首先我们让dp[1]=a[1]，接着开始往后枚举，我们每枚举一个就要判断dp中最后一位(dp[len])和a[i]的大小，如果a[i]更小，那么它可以作为这个子序列的下一项，（这里我们用len）也就是dp[++len]=a[i];如果a[i]大于dp[len]，就要使用二分法找到dp序列中小于a[i]的第一位，然后替换，这里换成了比原来大的数。比如：9 7 5 4 2 然后下一位是3，那么我们换掉比3小的第一位，也就是2，这时候，序列变成了9 7 5 4 3。 以此类推，遍历到最后，dp的长度len就是最长不上升子序列的长度。第二问的话，可能不好理解，因为如果有两枚导弹，第一枚先来，第二枚后来，而第一枚的高度比第二枚低，那么必须要两台才行，如果后面还有一枚导弹比第二枚导弹还要高，不就要三台了吗……以此类推。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std;int a[100010];int p[100010];int b[100010];int main()&#123; int i=0,len1=0,ans; while(~scanf(\"%d\",&amp;a[++i]));//循环输入 int n=i-1;//最后一次没有输入因此跳出循环，n=i-1 b[0] = 100000 ; b[++len1]=a[1]; for(i=2;i&lt;=n;i++)&#123; if(a[i]&lt;=b[len1])&#123; b[++len1]=a[i]; &#125; else &#123; int l=0,r=len1,mid; while(l&lt;=r)&#123; mid=l+(r-l)/2; if(a[i]&lt;=b[mid])&#123; ans=mid; l=mid+1; &#125; else r=mid-1; &#125; b[ans+1]=a[i]; &#125; /*for(int j=1;j&lt;=len1;j++)&#123; cout&lt;&lt;b[j]&lt;&lt;' '; &#125; cout&lt;&lt;endl;*/ &#125; cout&lt;&lt;len1&lt;&lt;endl; int sum=0; int m=0; while(m&lt;n)&#123; int last=10000000; for(int j=1;j&lt;=n;j++)&#123; if(a[j]&gt;0 &amp;&amp; a[j]&lt;=last)&#123; m++; last=a[j]; a[j]=-1; &#125; &#125; sum++; &#125; cout&lt;&lt;sum;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"CF 300C - Beautiful Numbers 数论","slug":"数论","date":"2022-02-23T01:46:41.000Z","updated":"2022-02-23T02:07:55.192Z","comments":true,"path":"2022/02/23/数论/","link":"","permalink":"https://kai-wei-kfuse.github.io/2022/02/23/%E6%95%B0%E8%AE%BA/","excerpt":"","text":"(广东工业大学 ACM寒假集训 专题四 C）题目链接：CF 300C - Beautiful Numbers洛谷链接：CF 300C - Beautiful Numbers更好的阅读体验请到这里 题目描述（洛谷翻译）：题意翻译Vitaly有一些奇怪的癖好，比如他特别爱两个小于10的数字a和b。Vitaly定义十进制表示下每一位都是a或b的数为“好数”，一个每一位数加起来为“好数”的“好数”被称为“极好的数”。 举个栗子=w=，如果偏爱数字为1和3，那么1212不是“好数”，13和311是“好数”，111是“极好的数”。 现在Vitaly想知道，长度为n（长度不包括前导0）的“极好的数”有多少个。对1e9+7取模。 读题1、有两个数字a，b。2、“好数”是只由a,b构成的长度为n的数。3、”好数”中每一位之和也是”好数”的数，叫“极好的数”。4、题目要我们找“极好的数”（以下简称极好数）。5、答案取模1e9+7，为质数。 总体思路：因为我们找的极好数来自好数，那么我们只要枚举长度为n的所有好数，判断是不是每一位之和为好数，是的话说明是极好数，结果累加起来就可以了。如何枚举：一个一个数枚举是不可能的，有1000000位数呢….但是仔细想一下，数的长度是固定为n的，且只有a,b，那么我们是不是就可以枚举a的数量i，那么b的数量一定是n-i，这时候这么多个a和b组成的数就相当于i个a去放n个空位(组合数),所以就是C（n,i）（n在下，i在上）。如何求这个组合数：简单，运用组合数公式：答案怎么求，如何求mod：我们不是求出来之后才取模。 分析：每个答案是一个组合数，但是组合数是一个分式，因为太大了，我们不能求出阶乘后再除下面的阶乘，我们要除数取模。（a/b）mod p ≠(a mod p/ b mod p)mod p这里我们要用费马小定理求逆元：$$\\frac{n!}{i!(n-i)!}$$由公式可知，我们要求 i! 和(n-i)!的逆元，让他变成乘法来取模。因为p是质数，所以可以用费马小定理，用快速幂求逆元。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;//组合数，费马小定理，快速幂,逆元using namespace std;const long long mod=1e9+7;long long fact[1000005];long long a,b,n,ans=0;bool good(long long x)&#123; while(x)&#123; long long tmp=x%10; if(tmp!=a &amp;&amp; tmp!=b)return false; x/=10; &#125; return true;&#125;long long fastpow(long long f,long long p)&#123; if(p==0)return 1; long long res=1; while(p)&#123; if(p&amp;1)res=res*f%mod; f=f*f%mod;//反正每次模就行，不要让他超longlong p&gt;&gt;=1; &#125; return res;&#125;int main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; fact[0]=1; for(int i=1;i&lt;=n;i++)fact[i]=fact[i-1]*i%mod;//打表，每次取模 for(int i=0;i&lt;=n;i++)&#123; if(good(a*i+b*(n-i)))&#123; long long tmp1=fastpow(fact[i],mod-2)%mod;//费马小定理求逆元 long long tmp2=fastpow(fact[n-i],mod-2)%mod;//求完就取模 ans+=fact[n]*tmp1%mod*tmp2%mod;//因为n!已经取过模了，所以是后面两个取 &#125; &#125; printf(\"%lld\\n\",ans%mod);//这里模不模都可以&#125; 好像也讲的不清楚….","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C++引用的概念","slug":"C-引用的概念","date":"2022-01-21T13:10:16.000Z","updated":"2022-01-21T13:59:21.262Z","comments":true,"path":"2022/01/21/C-引用的概念/","link":"","permalink":"https://kai-wei-kfuse.github.io/2022/01/21/C-%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/","excerpt":"","text":"C++中引用的概念和应用（初级应用）1、引用格式：类型名 &amp; 引用名=某变量名 下面发写法定义了一个引用： 12int n = 4;int &amp; r = n;//r引用了n，r的类型是int&amp; 如上代码，这里r就是一个引用，而r的类型是int&amp;。 某个变量的引用，等价于这个变量，相当于该变量的一个别名。 也就是说变量的引用和变量本身是一回事。 如下面的例子，r作为n的引用，对r赋值相当于对n赋值，对n赋值r也会做出改变。 1234567int n = 4;int &amp; r = n;r = 4;cout &lt;&lt; r;//输出 4cout &lt;&lt; n;//输出 4n = 5;cout &lt;&lt; r;//输出5 ———————————————————分割线 2、注意： 1、定义引用时一定要将其初始化成引用某个变量2、初始化后，它就一直引用该变量，不会再引用别的变量了。3、引用只能引用变量，不能引用常量和表达式。 看下面的例子：我们让r1引用了a，接着&amp; r2 = r1代表r2也引用了a，所以对r2赋值会影响到a；再下面我们让r1=b；如上面的注意所说，初始化后，它就一直引用该变量，也就是a，不会再引用别的变量了。 1234567double a = 4, b = 5;double &amp; r1 = a;double &amp; r2 = r1;// r2 也引用 ar2 = 10;cout &lt;&lt; a &lt;&lt; endl;// 输出 10r1 = b;// r1 并没有引用 bcout &lt;&lt; a &lt;&lt; endl;//输出 5 ———————————————————分割线3、我们为什么要引用？ C语言中，如何编写交换两个整型变量值的函数？我们都知道，需要用指针直接对地址交换。 1234567void swap( int *a, int *b)&#123; int tmp; tmp = * a; * a = * b; * b = tmp;&#125;int n1, n2;swap(&amp;n1, &amp;n2) ; // n1,n2 的值被交换 在c++的引用的帮助下，代码会简介更多。没有星号，调用的时候也不需要取地址。因为某个变量的引用，等价于这个变量，相当于该变量的一个别名，所以函数内交换了，就是n1 n2交换了。 12345678void swap( int &amp; a, int &amp; b)&#123; int tmp; tmp = a; a = b; b = tmp;&#125;int n1, n2;swap(n1,n2) ;// n1,n2 的值被交换 ———————————————————分割线4、常引用定义引用时，前面加const 关键字，即为“常引用”。比如： 12int n;const int &amp; r = n; 这里r的类型是 const int &amp;。 常引用不能通过常引用去修改其引用的内容，但是不代表本身不能被修改，可以通过其他方式修改。 123456int n = 100;const int &amp; r = n;r = 200;//编译错n = 300;// 没问题 ———————————————————分割线5、常引用和非常引用的转换 const T &amp;和 T &amp; 是不同的类型！ T &amp;类型的引用或 T 类型的变量可以用来初始化const T &amp; 类型的引用。 const T类型的常变量和 const T &amp; 类型的引用则不能用来初始化 T &amp; 类型的引用，除非进行 强制类型转换 。","categories":[],"tags":[]},{"title":"c语言菜单实现链表操作和文件读写实验（广工）","slug":"实验5","date":"2022-01-18T05:21:04.000Z","updated":"2022-01-18T12:28:53.055Z","comments":true,"path":"2022/01/18/实验5/","link":"","permalink":"https://kai-wei-kfuse.github.io/2022/01/18/%E5%AE%9E%E9%AA%8C5/","excerpt":"","text":"实验5链表操作：题目：编写一个链表综合程序,实现以下功能: 编写一个链表的构建函数输入任意多条的长度不等的字符串，结束的条件是直接回车，用动态链表方式处理保存各个字符串, 编写一个显示函数, 调用即显示前面所有输入过的字符串， 编写一个查询函数用以查询前面输入的字符串里是否有某字符串。 编写一个文件保存函数, 调用后链表上的所有字符串保存在文件data.txt里. 编写一个读文件添加链表数据的函数, 调用后,能把文件data.txt里的字符添加到当前的链表上 构建功能选择菜单, 通过菜单选择运行以上哪个函数的功能. （广东工业大学计算机） 第一部分：创建链表与打印首先我立马打了几个框架，第一次测试：失败 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct strings&#123; char s[100]; strings* next; &#125;;strings* head=NULL;//设置头指针，指向NULL;strings *create(int n)//创建链表&#123; strings *head=NULL,*node=NULL,*end=NULL; head=(strings*)malloc(sizeof(strings)); end=head;//初始链表只有一个头指针，所以尾等于头 while(gets(node-&gt;s)&amp;&amp;strcmp(node-&gt;s,\"\")!=0) //for(int i=0;i&lt;n;i++) &#123; node=(strings*)malloc(sizeof(strings));//每一次开辟一个空间 scanf(\"%s\",node-&gt;s); //node-&gt;s=a; end-&gt;next=node; end=node; &#125; end-&gt;next=NULL; return head;&#125;void print(strings* p)//打印&#123; //strings *p=head; int i=1; p = p-&gt;next; while(p!=NULL) &#123; printf(\"%d %s\",i,p-&gt;s); p=p-&gt;next; i++; &#125;&#125;int main()&#123; int n; scanf(\"%d\",n); head=create(n); print(head);&#125; 运行结果1： 无输出 思考：1、经过测试打印和创建都有问题修改：1、更换表达方式 1while(gets(node-&gt;s)&amp;&amp;strcmp(node-&gt;s,\"\")!=0) 改成 1while(gets(node-&gt;s)&amp;&amp;strlen(node-&gt;s)!=0) 2、更改打印的代码 12345678910void print(strings* p)//打印&#123; int i=1; while(p!=NULL) &#123; printf(\"%d %s\",i,p-&gt;s); p=p-&gt;next; i++; &#125;&#125; 删掉了一行p = p-&gt;next;这样才能输出第一个节点3、参考运行成功代码发现原来看的别人的博客写的代码是错的，根本运行不了（流汗）。第二次测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct strings&#123; char s[100]; strings* next; &#125;;strings* head=NULL;//设置头指针，指向NULL;strings * create()//创建链表&#123; int n=0; strings *head=NULL,*node=NULL,*end=NULL; node=(strings*)malloc(sizeof(strings)); end=node;//初始链表只有一个头指针，所以尾等于头 while(gets(node-&gt;s)&amp;&amp;strlen(node-&gt;s)!=0) &#123; n++; if(n==1)head=node; else end-&gt;next=node; end=node; node=(strings*)malloc(sizeof(strings)); &#125; end-&gt;next=NULL; return (head);&#125;struct strings *creat()&#123; struct strings *head,*p1,*p2; int n=0; head=NULL; p1=( struct strings *) malloc(sizeof(struct strings)); p2=p1; gets(p1-&gt;s); while(strlen(p1-&gt;s)!=0) &#123; n=n+1; if (n==1) head=p1; else p2-&gt;next=p1; p2=p1; p1=(struct strings *)malloc(sizeof(struct strings)); gets(p1-&gt;s); &#125; p2-&gt;next=NULL; return(head);&#125;void print(strings* p)//打印&#123; int i=1; while(p!=NULL) &#123; printf(\"%d %s \",i,p-&gt;s); p=p-&gt;next; i++; &#125;&#125;int main()&#123; head=create(); print(head);&#125; 运行成功。打印和创建函数完成。 第二部分：文件读写和添加节点添加节点放在这里是因为在添加节点的同时顺便写入文件。1、读取文件 123456FILE *fp=fopen(data,\"r\");//data是文件名if(fp==NULL) &#123; printf(\"Error\\n\");//如果读取失败输出失败 return; &#125; 和创建链表相同，每次打开文件都要重新读取重新创建链表；不同的是，输入不一样，变成了从文件读取，使用fscanf()函数，完整函数如下 解释：fscanf()：从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取 12345678910111213141516171819202122232425struct strings *readfile(char *data)//读取文件并且创建链表&#123; FILE *fp=fopen(data,\"r\"); if(fp==NULL) &#123; printf(\"Error\\n\"); return NULL; &#125;//和上面一样 struct strings *head,*node,*end; node=(struct strings*)malloc(sizeof(struct strings)); end=node; int n=0; while(fscanf(fp,\"%s\",node-&gt;s)!=EOF)//和前面不同的是这里，从文件读取 &#123; n++; if(n==1) head=node; else end-&gt;next=node; end=node; node=(struct strings*)malloc(sizeof(struct strings)); &#125; end-&gt;next=NULL; return head;&#125; 2、保存到文件这里要了解几个函数（菜鸟教程）①fputc()函数函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。②fputs()函数函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。③fprintf()函数int fprintf(FILE *fp,const char *format, …) 函数把一个字符串写入到文件中。 12345678910111213141516void save(struct strings *p,char *data)//保存到文件&#123; FILE *fp=fopen(data,\"w\"); if (fp==NULL) &#123; printf(\"Error\\n\"); return; &#125; //----一模一样的如果读取失败输出失败----- while(p!=NULL) &#123; fprintf(fp,\"%s\\n\",p-&gt;s); p=p-&gt;next; &#125; fclose(fp);&#125; 3、添加节点添加手动输入的字符 1234567891011121314151617struct strings *addtofile(struct strings *head)//添加节点&#123; struct strings *ne; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings));//先开辟空间 gets(ne-&gt;s);//输入手动输入的字符 if (strlen(ne-&gt;s)!=0) &#123; head=addtolist(head,ne);//添加节点函数在下面 &#125; else&#123; free(ne);//如果没了就释放掉 break; &#125; &#125; return head;&#125; 123456789101112131415struct strings *addtolist(struct strings *head,struct strings* news)//添加节点&#123; struct strings* p=head; if (head==NULL)&#123;//似乎一定要写这个if，不然就无输出 head=news; news-&gt;next=NULL; return head; &#125; while (p-&gt;next!=NULL)&#123; p=p-&gt;next; &#125; p-&gt;next=news; news-&gt;next=NULL; return head;&#125; 4、程序主体这是实现文件读写的链表程序，read file读取文件并且输出，在add：后面输入字符，如果回车两次，即没有输入，则会打印整个链表程序如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct strings&#123; char s[100]; struct strings* next; &#125;;struct strings* head=NULL;//设置头指针，指向NULL;struct strings * create()//创建链表&#123; int n=0; struct strings *head=NULL,*node=NULL,*end=NULL; node=(struct strings*)malloc(sizeof(struct strings)); end=node;//初始链表只有一个头指针，所以尾等于头 while(gets(node-&gt;s)&amp;&amp;strlen(node-&gt;s)!=0) &#123; n++; if(n==1)head=node; else end-&gt;next=node; end=node; node=(struct strings*)malloc(sizeof(struct strings)); &#125; end-&gt;next=NULL; return (head);&#125;void print(struct strings* p)//打印&#123; int i=1; while(p!=NULL) &#123; printf(\"%s\\n\",p-&gt;s); p=p-&gt;next; i++; &#125;&#125;void save(struct strings *p,char *filename)//保存到文件&#123; FILE *fp=fopen(filename,\"w\"); if (fp==NULL) &#123; printf(\"Error\\n\"); return; &#125; while(p!=NULL) &#123; fprintf(fp,\"%s\\n\",p-&gt;s); p=p-&gt;next; &#125; fclose(fp);&#125;struct strings *readfile(char *data)//读取文件并且创建链表&#123; FILE *fp=fopen(data,\"r\"); if(fp==NULL) &#123; printf(\"Error\\n\"); return NULL; &#125; struct strings *head,*node,*end; node=(struct strings*)malloc(sizeof(struct strings)); end=node; int n=0; while(fscanf(fp,\"%s\",node-&gt;s)!=EOF)//和前面不同的是这里 &#123; n++; if(n==1) head=node; else end-&gt;next=node; end=node; node=(struct strings*)malloc(sizeof(struct strings)); &#125; end-&gt;next=NULL; return head;&#125;struct strings *addtolist(struct strings *head,struct strings* news)//添加节点&#123; struct strings* p=head; if (head==NULL)&#123; head=news; news-&gt;next=NULL; return head; &#125; while (p-&gt;next!=NULL)&#123; p=p-&gt;next; &#125; p-&gt;next=news; news-&gt;next=NULL; return head;&#125;struct strings *addtofile(struct strings *head)//添加节点&#123; struct strings *ne; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings)); gets(ne-&gt;s); if (strlen(ne-&gt;s)!=0) &#123; head=addtolist(head,ne); &#125; else&#123; free(ne); break; &#125; &#125; return head;&#125;int main()&#123; printf(\"read file:\\n\"); head=readfile(\"data.txt\");//读取文件并创建链表 print(head);//打印 printf(\"add:\\n\"); addtofile(head);//添加字符串到链表 printf(\"display:\\n\"); print(head); save(head,\"data.txt\");//保存 //head=create();&#125; 第三部分：菜单实现一、两个键盘读取函数：1、检测输入按键函数getch()函数返回按键的数值； UP = 72 DOWN = 80 LEFT = 75 RIGHT = 77 ENTER = 13 ESC = 27 //按键数值 2、函数kbhit() 检查当前是否有键盘输入，若有则返回一个非0值，否则返回0 。函数名：kbhit()（VC++6.0下为_kbhit()）用法：int kbhit(void);包含头文件： include &lt;conio.h&gt;两者区别：kbhit() 在执行时,检测是否有按键按下,有按下返回非0值，一般是1；没有按下返回0；是非阻塞函数。getch() 在执行时，检测按下什么键，如果不按键该函数不返回，是阻塞函数 二、设置文本样式我们需要制作一个菜单，使用方向键选择选项，并且高亮显示，这里就需要设置字体格式，使用SetConsoleTextAttribute()函数可以设置文字颜色和高亮。 1SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),0x70);//高亮显示 1SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),0x07);//正常显示 这里是简短的测试程序 12345678910111213141516171819202122232425262728#include&lt;stdlib.h&gt;//测试读取键盘和设置高亮#include&lt;conio.h&gt;#include&lt;windows.h&gt;#include&lt;stdio.h&gt;int main()&#123; while(true)&#123; if(kbhit())&#123; char c=getch(); if(GetAsyncKeyState(VK_UP)) printf(\"up,\"); if(GetAsyncKeyState(VK_DOWN)) printf(\"Down,\"); //读取到上或者下就对应输出 if(GetAsyncKeyState(VK_LEFT))&#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),0x70); printf(\"\\nHighlight,\"); &#125; if(GetAsyncKeyState(VK_RIGHT))&#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),0x07); printf(\"\\nNormal,\"); //读取到左或者右就高亮或恢复（如果高亮则恢复，正常则不变） &#125; Sleep(100); &#125; &#125; return 0;&#125; 程序结果三、显示菜单并且高亮读取键盘完成了，就需要显示出菜单界面，我们设置一个char数组来储存。 123456789char MenuText[7][30]=&#123; \"[A] Create a List \", \"[B] Display the List \", \"[C] Find the Word \", \"[D] Save to File \", \"[E] Read to List \", \"[F] Add to List \", \"[Q] Exit \"&#125;; 将他打印出来的话，就是正常的样子。但是我们需要让他高亮，这里就需要思考，如何让特定的选项高亮呢？这里我们在打印菜单函数coutmenu（）函数里面设置了一个变量highlight，他的值是多少代表是第几行需要高亮。接着我们使用for循环7次（有7行）一次输出，这样菜单里面就有一个选项是高亮的。 1234567891011121314151617void coutmenu(int highlight)//打印菜单函数&#123; int i; printf(\"\\n======================\\n\");//只是输出边界线 for (i=0;i&lt;7;i++)&#123; if (i==highlight-1) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0x70); //设置高亮 else SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0x07); //设置正常 printf(\"%s\\n\",MenuText[i]);//设置完成后输出 &#125; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7); printf(\"======================\\n\"); &#125; 如图所示（假设这里highlight=2，那么第二行就会高亮）不知道大家有没有想到，怎么让他按照我们的意愿高亮。想不到也没关系，我也想不到，这里我们通过反复清空屏幕，再反复输出的方式，来实现上下移动。 四、实现选项移动因为我们要反复输出我们就需要清空屏幕，这里我们用system(&quot;cls&quot;);来清空屏幕。同时我们需要使用sleep()函数来让程序暂停，如果数值设置太短，我们按方向键的时候，可能已经经过了好多个循环，相当于你按了n多次方向键，会跳的很快。 123456789101112131415for(;;)&#123; if (kbhit())&#123; c=getch(); if (GetAsyncKeyState(VK_UP))&#123; high=(high&gt;1)?high-1:7;//程序的巧妙之处，超过7则回退到1 Sleep(140); system(\"cls\"); coutmenu(high);//打印菜单函数 &#125; if (GetAsyncKeyState(VK_DOWN))&#123; high=(high&lt;7)?high+1:1; Sleep(140); system(\"cls\"); coutmenu(high); &#125;&#125;&#125; （这里是另一个函数，所以高亮显示的行号用high表示）这个程序的巧妙之处在于每次收到上下的信号就会对变量high做出运算，DOWN的情况是大于7则变成1，小于7则加1。这样在第七行（最后一行），再按一次down就会回到第一行。不过这个回退不是必要的，也可以不加。五、按回车执行对应程序在前面的if语句后面接上 if 语句，判断是否回车，回车符是&#39;\\r&#39;，接着用swich语句来判断情况执行语句。 12345678910111213141516171819202122else if(c=='\\r')&#123;//判断回车 system(\"cls\");//清空屏幕 coutmenu(high);//再打印 printf(\"command is [%c]\",'A'+high-1);//同时输出在执行的选项（测试用，后面可以删） switch (high) &#123; case 1:printf(\"1\");//后面需要加上代码 break; case 2:printf(\"2\"); break; case 3:printf(\"3\"); break; case 4:printf(\"4\"); break; case 5:printf(\"5\"); break; case 6:printf(\"6\"); break; case 7:printf(\"7\"); break; &#125; &#125; 效果如图，按回车后才回显示 第四部分：加上查找功能没有太大难度，基础的查找操作 12345678910111213141516171819void find(struct strings *head)//查找&#123; char* word; gets(word); struct strings *p=head; int i=1; //p=p-&gt;next; while(p!=NULL) &#123; if(strcmp(p-&gt;s,word)==0) &#123; printf(\"Search successfully\\n\"); return ; &#125; p=p-&gt;next; &#125; printf(\"Search unsuccessfully!\\n\"); return ;&#125; 第五部分：把菜单整合到链表程序中所有工作都分工做完了，现在就剩下整合合微调了。一、判断语句设置这是整合后的Switch函数，这里的函数一定要调用对，别搞错了，所以函数命名的时候一定要清楚。 123456789101112131415161718192021222324252627282930313233switch (high) &#123; system(\"cls\"); coutmenu(high); case 1: printf(\"add:\\n\");//创建链表，并且手动输入 head=create(); break; case 2: print(head);//打印 break; case 3: printf(\"Input your word which you want to find:\");//查找 find(head); break; case 4: save(head,\"data.txt\");//保存到文件（会清空原本） break; case 5: //head=readfile(\"data.txt\"); head=addinlist(head,\"data.txt\");//(读取文件的内容添加到链表后面） break; case 6: printf(\"add:\");//手动输入添加字符串到链表后面 addtofile(head); break; case 7: return 0;//退出 break; &#125; //对应处理的程序段 printf(\"command %c finished\",'A'+high-1); &#125; 二、修改一个函数这里前面一个函数需要修改才能使用，因为实现的功能是读取文件内容，把内容添加到链表后面，不是手动输入，所以前面的addtofile函数需要修改。 修改前： 1234567891011121314151617struct strings *addtofile(struct strings *head)//添加节点&#123; struct strings *ne; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings)); gets(ne-&gt;s); if (strlen(ne-&gt;s)!=0) &#123; head=addtolist(head,ne); &#125; else&#123; free(ne); break; &#125; &#125; return head;&#125; 先把文件读写的代码加上去FILE *fp=fopen(data,&quot;r&quot;);同样加上是否读取文件成功的判断，gets改成fscanf(fp,&quot;%s&quot;,ne-&gt;s)。修改后： 12345678910111213141516171819202122struct strings *addinlist(struct strings *head,char* data)&#123; struct strings *ne; FILE *fp=fopen(data,\"r\"); if(fp==NULL) &#123; printf(\"Error\\n\"); return NULL; &#125; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings)); if (fscanf(fp,\"%s\",ne-&gt;s)!=EOF) &#123; head=addtolist(head,ne); &#125; else&#123; free(ne); break; &#125; &#125; return head;&#125; 最后就完成了。 附加：按字母键跳转选项菜单前面有ABCDEF,其实还可以通过按字母跳转，原理相同，关键在于求出高亮的是第几行。 12345678if (c&lt;='z'&amp;&amp; c&gt;='a')c=c-('a'-'A'); if (c&lt;='F' &amp;&amp; c&gt;='A')&#123; //对应处理的程序段 high=c-'A'+1; system(\"cls\"); coutmenu(high); printf(\"command [%c] \",c); &#125; 完整代码（运行平台vscode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;struct strings&#123; char s[100]; struct strings* next; &#125;;char MenuText[7][40]=&#123; \"|[A] Create a List |\", \"|[B] Display the List |\", \"|[C] Find the Word |\", \"|[D] Save to File |\", \"|[E] Read to List |\", \"|[F] Add to List |\", \"|[Q] Exit |\"&#125;;void coutmenu(int highlight)&#123; int i; printf(\"\\n---------------------------\\n\"); for (i=0;i&lt;7;i++)&#123; if (i==highlight-1) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0x70); else SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0x07); printf(\"%s\\n\",MenuText[i]); &#125; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7); printf(\"---------------------------\\n\"); &#125;struct strings* head=NULL;//设置头指针，指向NULL;struct strings * create()//创建链表&#123; int n=0; struct strings *head=NULL,*node=NULL,*end=NULL; node=(struct strings*)malloc(sizeof(struct strings)); end=node;//初始链表只有一个头指针，所以尾等于头 while(gets(node-&gt;s)&amp;&amp;strlen(node-&gt;s)!=0) &#123; n++; if(n==1)head=node; else end-&gt;next=node; end=node; node=(struct strings*)malloc(sizeof(struct strings)); &#125; end-&gt;next=NULL; return (head);&#125;void print(struct strings* p)//打印&#123; int i=1; while(p!=NULL) &#123; printf(\"%s\\n\",p-&gt;s); p=p-&gt;next; i++; &#125;&#125;void find(struct strings *head)//查找&#123; char* word; gets(word); struct strings *p=head; int i=1; //p=p-&gt;next; while(p!=NULL) &#123; if(strcmp(p-&gt;s,word)==0) &#123; printf(\"Search successfully\\n\"); return ; &#125; p=p-&gt;next; &#125; printf(\"Search unsuccessfully!\\n\"); return ;&#125;void save(struct strings *p,char *filename)//保存到文件&#123; FILE *fp=fopen(filename,\"w\"); if (fp==NULL) &#123; printf(\"Error\\n\"); return; &#125; while(p!=NULL) &#123; fprintf(fp,\"%s\\n\",p-&gt;s); p=p-&gt;next; &#125; fclose(fp);&#125;struct strings *readfile(char *data)//读取文件并且创建链表&#123; FILE *fp=fopen(data,\"r\"); if(fp==NULL) &#123; printf(\"Error\\n\"); return NULL; &#125; struct strings *head,*node,*end; node=(struct strings*)malloc(sizeof(struct strings)); end=node; int n=0; while(fscanf(fp,\"%s\",node-&gt;s)!=EOF)//和前面不同的是这里 &#123; n++; if(n==1) head=node; else end-&gt;next=node; end=node; node=(struct strings*)malloc(sizeof(struct strings)); &#125; end-&gt;next=NULL; return head;&#125;struct strings *addtolist(struct strings *head,struct strings* news)//添加节点&#123; struct strings* p=head; if (head==NULL)&#123; head=news; news-&gt;next=NULL; return head; &#125; while (p-&gt;next!=NULL)&#123; p=p-&gt;next; &#125; p-&gt;next=news; news-&gt;next=NULL; return head;&#125;struct strings *addtofile(struct strings *head)//添加节点&#123; struct strings *ne; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings)); gets(ne-&gt;s); if (strlen(ne-&gt;s)!=0) &#123; head=addtolist(head,ne); &#125; else&#123; free(ne); break; &#125; &#125; return head;&#125;struct strings *addinlist(struct strings *head,char* data)&#123; struct strings *ne; FILE *fp=fopen(data,\"r\"); if(fp==NULL) &#123; printf(\"Error\\n\"); return NULL; &#125; for (;;)&#123; ne=(struct strings *) malloc(sizeof(struct strings)); if (fscanf(fp,\"%s\",ne-&gt;s)!=EOF) &#123; head=addtolist(head,ne); &#125; else&#123; free(ne); break; &#125; &#125; return head;&#125;int main()&#123; char c; int high=1; coutmenu(high); for(;;)&#123; if (kbhit())&#123; c=getch(); if (GetAsyncKeyState(VK_UP))&#123; high=(high&gt;1)?high-1:7; Sleep(140); system(\"cls\"); coutmenu(high); &#125; if (GetAsyncKeyState(VK_DOWN))&#123; high=(high&lt;7)?high+1:1; Sleep(140); system(\"cls\"); coutmenu(high); &#125; if (c&lt;='z'&amp;&amp; c&gt;='a')c=c-('a'-'A'); if (c&lt;='F' &amp;&amp; c&gt;='A')&#123; //对应处理的程序段 high=c-'A'+1; system(\"cls\"); coutmenu(high); printf(\"command [%c] \",c); &#125; else if (c=='\\r')&#123; switch (high) &#123; system(\"cls\"); coutmenu(high); case 1: printf(\"Add strings:\\n\"); head=create(); break; case 2: print(head); break; case 3: printf(\"Input your word which you want to find:\"); find(head); break; case 4: save(head,\"data.txt\"); break; case 5: //head=readfile(\"data.txt\"); head=addinlist(head,\"data.txt\"); break; case 6: printf(\"Add strings:\"); addtofile(head); break; case 7: return 0; break; &#125; //对应处理的程序段 printf(\"command %c finished\",'A'+high-1); &#125; else if (c=='Q') return 0; /*printf(\"read file:\\n\"); head=readfile(\"data.txt\");//读取文件并创建链表 print(head);//打印 printf(\"add:\\n\"); addtofile(head); printf(\"display:\\n\"); print(head); save(head,\"data.txt\"); */ //head=create(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://kai-wei-kfuse.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"你好，访客","slug":"hello-world","date":"2022-01-18T04:42:09.776Z","updated":"2020-04-11T03:57:40.000Z","comments":true,"path":"2022/01/18/hello-world/","link":"","permalink":"https://kai-wei-kfuse.github.io/2022/01/18/hello-world/","excerpt":"","text":"创建这个博客算是跟风的吧，不过我确实想有一个平台可以自己有个性化的形式写教程写文章什么什么的，所以就花了好大力气创建了这个博客。 索引博客有什么内容？目前的计划： 1234hexo+github个人博客创建及美化泰拉瑞亚全流程攻略魔方教程与魔方测评我家的猫 其他平台哔哩哔哩: kai_wei凯惟 交流QQ:1171113925欢迎骚扰O(∩_∩)O 打赏（未完工）马上就来","categories":[{"name":"索引","slug":"索引","permalink":"https://kai-wei-kfuse.github.io/categories/%E7%B4%A2%E5%BC%95/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"edge浏览器简单设置","slug":"edge","date":"2020-05-02T02:34:19.000Z","updated":"2020-05-03T03:01:46.000Z","comments":true,"path":"2020/05/02/edge/","link":"","permalink":"https://kai-wei-kfuse.github.io/2020/05/02/edge/","excerpt":"","text":"edge出了问题？edge的简单设置帮你解决 Edge是微软出品的浏览器，这里不多做介绍。 主要讲讲在edge设置菜单的各种功能，使用过程中出现的问题，怎么通过设置解决。 问题一：刚打开浏览器是别的网页而不是新标签页 别的网页（比如什么上网导航什么的） 新标签页（上图就是新标签页） 这时候就有两种可能： 1、被网页劫持了，这时可能电脑中了病毒，杀毒可以解决（把浏览器设置改了之后不行的话才是） 2、浏览器设置被改了（可能是被别的软件改的，因为一般人不会去点那个） 点右上角的策略号，找到设置打开 然后找到启动时，选择新标签页，再关掉浏览器重开。 问题二：搜索的时候没办法在搜索框输入，而只能在顶部输入下图：搜索框，这个问题困扰了我很久，只要在搜索框输入任何东西，都会自动弹到地址栏那里，而且这种情况是突然出现的，我也没改设置。 解决方法，同样是打开设置 点击隐私与服务，往下拉，找到服务最下面的地址栏 如果这里显示的是地址栏，那么就改成搜索框，问题就解决了 问题三：新标签页如何隐藏下面的广告/新闻（如何美化新标签页） 新标签页右上角有个设置，点击如何选择自定义，看自己喜好选择内容显示还是不显示，内容就是指那些新闻和广告什么的。 这里就是edge的简单设置，这是其中一部分，以后会写更多的。","categories":[],"tags":[{"name":"软件应用","slug":"软件应用","permalink":"https://kai-wei-kfuse.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"}]},{"title":"win10怎么激活？win10一键激活","slug":"win10激活","date":"2020-04-30T02:34:19.000Z","updated":"2020-04-30T08:22:06.000Z","comments":true,"path":"2020/04/30/win10激活/","link":"","permalink":"https://kai-wei-kfuse.github.io/2020/04/30/win10%E6%BF%80%E6%B4%BB/","excerpt":"","text":"win10怎么激活？win10一键激活我们辛辛苦苦把windows装好了以后，那么就可以正常使用windows了。 还不知道怎么装win10？点这里 https://kai-wei-kfuse.github.io/2020/04/13/win10/#more 下一步就是激活windows首先说说不激活windows和激活有什么区别答案：没什么区别，只是右下角会有一个激活windows水印，不影响正常使用。 激活并不难，只要一个激活工具，一键就可以激活。这里推荐小马激活工具 度盘：https://pan.baidu.com/s/1hYF7mYaR42gt5Fe-omMgHQ 提取码：buhb","categories":[],"tags":[{"name":"系统相关","slug":"系统相关","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"}]},{"title":"win10 U盘装机法","slug":"win10","date":"2020-04-13T02:34:19.000Z","updated":"2020-04-15T03:56:36.000Z","comments":true,"path":"2020/04/13/win10/","link":"","permalink":"https://kai-wei-kfuse.github.io/2020/04/13/win10/","excerpt":"","text":"#装机教程# Windows 10 U盘装机windows 10目前越来越普及，目前（2020年）win 10用户已经超过了win7，如下图（这张图是一年前的，很旧了，现在肯定不止这个数据）而且微软官方已经停止了对win 7的支持。 所以，windows 10 大势所趋，还不赶紧装个win10玩玩？问题来了：怎么装个win10？不急，下面告诉你 1.什么是U盘装机？适用于什么情况？U盘装机就是用一个 在U盘里的小系统 （即win PE系统）把你要装的系统安装在主机上 的方法，他是个万能的方法，没有什么限制，如果你的电脑是一台新的电脑（里面没有系统），那么就可以用这个方法，只要有个U盘就行。如果是win7升级win10也可以用这个方法。注意的是，你的C盘（系统盘）需要格式化，这里提醒一下，格式化后面再说。 想知道你适用于哪种装机方法的可以看这里-&gt;（链接） 2.准备工作这里要准备一个硬件和一个工具和一个系统镜像。 ① 一个空U盘，大小4G以上（win PE大概占2G）如果没有空U盘也可以把U盘内文件备份一次（就复制出来） 装PE会格式化U盘！！！ ② 下载winPE可以百度搜win pe 或者 点这里http://www.wepe.com.cn/在官网下 ③ 下载win10镜像（镜像就是一个用来安装系统文件）在MSDN下载https://msdn.itellyou.cn/如图，操作系统&gt;win10&gt;选择版本&gt;详细信息&gt;复制链接 在迅雷下载即可 注意！x64：64位系统 x86：32位系统 business：商业版（也就是专业版） consumer：消费者版（也就是普通版） 3.第一步：安装winPE进U盘里什么是winPE？win PE就是专门用来装系统的系统，也就是预装系统的系统，它是一种系统预装环境和工具。 打开安装到U盘（右下） 注意待写入U盘是不是那个空U盘 然后就点安装，等它完成。（安装的时候你会发现你不能打开U盘） 然后你会发现你的U盘容量变小了，这部分就是PE系统占了。这样你的U盘就能恢复平常正常使用了，不过我推荐还是有一个专门的装机盘会好一点（几十块一个U盘够用好多年呢）。 4.第二步：把你下载的系统镜像放入U盘方便在pe系统内找到你下的镜像，这个写着10的长的要死的就是镜像文件，图标上有个光盘的样子。 5.第三步：重启电脑，设置U盘启动重启电脑，在显示主板牌子的时候按F8（不同品牌的按键不一定一样，有的F12或者F11，一般屏幕底部会显示）进入BIOS，这里建议百度如何进入BIOS。我的BIOS是三代，如果是2代或1代（跟我不一样的建议百度”BIOS”），不用在意不同品牌的按键布局，反正功能肯定是有的，进入界面会有一个启动顺序，找到你U盘的型号移到前面就行。也可以点高级模式，在启动选项设置，1、2、3的顺序就是启动顺序。设置成功的话，点击退出，并保存设置。然后电脑会再一次启动，启动成功会出现进度条，进度条过完后会有win10图标。打开之后就是下图的样子。然后，打开你的U盘，找到你的镜像文件，右键点击装载（这里会生成一个虚拟光驱），然后下一步 6.第四步：格式化硬盘格式化掉你要装系统的那个硬盘，右键硬盘就能格式化，或者用PE里自带的分区助手备份一次再格式化也可以，注意看看硬盘是不是NTFS格式，如果不是要转到NTFS格式。 7.第五步：打开windows安装器,开始安装系统打开桌面的windows安装器如图，第一个选择你刚刚装载的虚拟光驱，然后按这个路径sources&gt;install.wim，下面两个都选你要装系统的硬盘（你刚刚格式化那个），然后选择版本（各版本区别可以自己查，这里推荐专业版）。然后就可以点开始安装了。 安装完成就拔掉U盘，重启电脑就可以了。然后就会显示win10的安装界面，接着就是选语言等等的界面，之后的这里就不多说了，按它的默认选项就好了。 然后你的win10就装好了。欢呼吧！！！","categories":[],"tags":[{"name":"系统相关","slug":"系统相关","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"}]},{"title":"泰拉瑞亚模组冲突如何解决","slug":"泰拉瑞亚","date":"2020-04-11T02:34:19.000Z","updated":"2020-04-13T02:05:20.000Z","comments":true,"path":"2020/04/11/泰拉瑞亚/","link":"","permalink":"https://kai-wei-kfuse.github.io/2020/04/11/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/","excerpt":"","text":"如何快速找出模组冲突首先你可以大概推测（这一步可做可不做），想想模组从哪里下，版本对不对，下载的可能是有问题的。 准备工作： 创建一个空的测试角色（每次排查都要用它） 把模组分类：主要模组、次要模组、功能性模组等等方便排查 确定mod冲突的类型，我大致分三类，无法加载模组（其实这个直接能看到不用排查）、无法创建世界（卡住或崩溃）、能进游戏能正常玩耍，但是出现小bug（比如我出现过的：一个召唤物只能杀一个敌人，然后召唤物就消失了、模组掉落物无法掉落） 如图，创建世界的时候卡在这里。 1.全部模组禁用全部禁用，一个不剩 2.先启用大型模组（如果有的话），比如灾厄，瑟银等等，一次启用1-4个（如果你有那么多的话）。然后用测试角色，然后就按照你发现的bug或冲突进行测试 举个栗子：无法创建世界（卡在一个位置创建不了）这时就要用测试角色创建世界（时间可能稍久，但没有办法） 3.然后就有两个分支①发现问题这时就要看启用的几个模组（范围大大缩小），一个一个禁用，顺序可以随便定，注意禁用之后还有问题的话禁用的就先别启用，直到找出问题mod。（如果bug消失，那应该是你这次测试禁用的mod有冲突，这就是问题mod）找出后启用刚刚第一次测试的几个大型mod，出现问题的mod不用开，再测试有没有出现bug。 ②没有问题这时要保持大型mod启用，在启用次要mod，跟前面一样以此类推，找到最终问题。 总的来说，据我所知找模组冲突没有特别简便的方法，只有靠自己一一排除，也没有什么软件可以一键查出，所以下模组的时候也要谨慎，每个模组都是独立开发的，互相有冲突实属正常，最后希望大家能找到好玩又没有冲突的整合包！！！","categories":[],"tags":[{"name":"泰拉瑞亚","slug":"泰拉瑞亚","permalink":"https://kai-wei-kfuse.github.io/tags/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/"}]},{"title":"泰拉瑞亚原版全流程攻略","slug":"first-text","date":"2020-04-05T13:35:55.000Z","updated":"2020-04-07T07:07:02.000Z","comments":true,"path":"2020/04/05/first-text/","link":"","permalink":"https://kai-wei-kfuse.github.io/2020/04/05/first-text/","excerpt":"","text":"废话：《泰拉瑞亚》是由Re-Logic公司开发的一款高自由度的沙盒游戏，于2011年5月16日在PC上发行。攻略开始：正在开发…正在开发..正在开发…正在开发….正在开发…","categories":[{"name":"泰拉瑞亚","slug":"泰拉瑞亚","permalink":"https://kai-wei-kfuse.github.io/categories/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/"}],"tags":[{"name":"泰拉瑞亚","slug":"泰拉瑞亚","permalink":"https://kai-wei-kfuse.github.io/tags/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/"}]}],"categories":[{"name":"索引","slug":"索引","permalink":"https://kai-wei-kfuse.github.io/categories/%E7%B4%A2%E5%BC%95/"},{"name":"泰拉瑞亚","slug":"泰拉瑞亚","permalink":"https://kai-wei-kfuse.github.io/categories/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"c语言","slug":"c语言","permalink":"https://kai-wei-kfuse.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"索引","slug":"索引","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"软件应用","slug":"软件应用","permalink":"https://kai-wei-kfuse.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"},{"name":"系统相关","slug":"系统相关","permalink":"https://kai-wei-kfuse.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"},{"name":"泰拉瑞亚","slug":"泰拉瑞亚","permalink":"https://kai-wei-kfuse.github.io/tags/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A/"}]}